# Snakefile

import os
import glob
import re
import sys

current_path = os.getcwd()
raw_data_dir = config["rawdatadir"]

# Only match files that truly contain "_R1" or ".R1" before something else (like extension)
R1_files = [
    f for f in glob.glob(os.path.join(raw_data_dir, '*'))
    if re.search(r'[_\.]R1[^0-9]', os.path.basename(f))  # ensures "R1" not followed by another digit
]

if not R1_files:
    sys.exit(f"ERROR: No '_R1' or '.R1' files found in '{raw_data_dir}'")

sample_suffixes = {}

for f in R1_files:
    basename = os.path.basename(f)

    # Match sample name, separator, and suffix strictly
    match = re.match(r'(.+?)([_\.])R1(.*)', basename)
    if not match:
        sys.exit(f"ERROR: File '{basename}' does not contain '_R1' or '.R1' pattern.")

    sample, sep, suffix = match.groups()
    sample_suffixes[sample] = (sep, suffix)

SAMPLES = list(sample_suffixes.keys())


rule all:
    input:
        os.path.join(current_path, "results", "00-prepare", config["outputprepare"] + ".fasta"),
        os.path.join(current_path, "results", "00-prepare", config["outputprepare"] + "_withSingleton.fasta")

rule prepare_directories:
    input:
        full_path_raw = config["rawdatadir"]
    output:
        r1_files = [os.path.join(current_path, "results", "00-prepare", "prepare_output", f"R1/{sample}{sep}R1{suffix}") for sample, (sep, suffix) in sample_suffixes.items()],
        r2_files = [os.path.join(current_path, "results", "00-prepare", "prepare_output", f"R2/{sample}{sep}R2{suffix}") for sample, (sep, suffix) in sample_suffixes.items()]
    shell:
        """
        mkdir -p {current_path}/results/00-prepare/prepare_output/R1 {current_path}/results/00-prepare/prepare_output/R2

        # Copy both _R1 and .R1 files
        cp {input.full_path_raw}/*_R1* {current_path}/results/00-prepare/prepare_output/R1/ 2>/dev/null || true
        cp {input.full_path_raw}/*.R1* {current_path}/results/00-prepare/prepare_output/R1/ 2>/dev/null || true

        # Copy both _R2 and .R2 files
        cp {input.full_path_raw}/*_R2* {current_path}/results/00-prepare/prepare_output/R2/ 2>/dev/null || true
        cp {input.full_path_raw}/*.R2* {current_path}/results/00-prepare/prepare_output/R2/ 2>/dev/null || true
        """

rule run_adapter_removal:
    input:
        r1 = lambda wildcards: os.path.join(
            current_path,
            "results", "00-prepare", "prepare_output",
            f"R1/{wildcards.sample}{sample_suffixes[wildcards.sample][0]}R1{sample_suffixes[wildcards.sample][1]}"
        ),
        r2 = lambda wildcards: os.path.join(
            current_path,
            "results", "00-prepare", "prepare_output",
            f"R2/{wildcards.sample}{sample_suffixes[wildcards.sample][0]}R2{sample_suffixes[wildcards.sample][1]}"
        )
    output:
        os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.discarded"),
        os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair1.truncated"),
        os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair2.truncated"),
        os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.settings"),
        os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.singleton.truncated")
    params:
        adapters = config["adapters"],
        num_threads = config["num_threads"],
        min_phred = config["minphred"],
        min_length = config["minlength"]
    log:
        os.path.join(current_path, "results", "00-prepare", "logs", "adapter_removal", "{sample}.log")
    benchmark:
        os.path.join(current_path, "results", "benchmark", "{sample}_prepare_adapter_removal.txt")
    singularity:
        "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_adapterremoval")
    shell:
        """
        cd {current_path}/results/00-prepare/prepare_output/
        AdapterRemoval --file1 {input.r1} --file2 {input.r2} --threads {params.num_threads} \
        --mate-separator " " --adapter-list {params.adapters} \
        --trimwindows 10 --minquality {params.min_phred} --minlength {params.min_length} \
        --qualitymax 64 --basename {wildcards.sample}_good --mm 5 \
        > {log} 2>&1

        rm {input.r1} {input.r2}
        """

if config["merger"] == "pear":
    rule run_pear:
        input:
            pair1 = os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair1.truncated"),
            pair2 = os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair2.truncated"),
        output:
            os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.assembled.fastq"),
            os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.discarded.fastq"),
            os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.forward.fastq"),
            os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.reverse.fastq")
        params:
            num_threads = config["num_threads"],
            minoverlap = config["minoverlap"]
        log:
            os.path.join(current_path, "results", "00-prepare", "logs", "pear", "{sample}.log")
        benchmark:
            os.path.join(current_path, "results", "benchmark", "{sample}_prepare_pear.txt")
        singularity:
            "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_pear")
        shell:
            """
            mkdir -p {current_path}/results/00-prepare/assemblies/{wildcards.sample}
            pear -j {params.num_threads} -f {input.pair1} -v {params.minoverlap} -r {input.pair2} -o {current_path}/results/00-prepare/assemblies/{wildcards.sample}/{wildcards.sample} \
            > {log} 2>&1
            for i in {current_path}/results/00-prepare/assemblies/{wildcards.sample}/*.assembled.fastq; do sed -i "s/ /_/g" $i; done
            """
else:
    rule run_overlapper:
        input:
            pair1 = os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair1.truncated"),
            pair2 = os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.pair2.truncated"),
        output:
            assembled = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.assembled.fastq"),
            un_forward = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.forward.fastq"),
            un_reverse = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.reverse.fastq")
        params:
            minoverlap = config["minoverlap"],
            minsim = config["minsim"]
        log:
            os.path.join(current_path, "results", "00-prepare", "logs", "overlapper", "{sample}.log")
        benchmark:
            os.path.join(current_path, "results", "benchmark", "{sample}_prepare_overlapper.txt")
        shell:
            """
            mkdir -p {current_path}/results/00-prepare/assemblies/{wildcards.sample}
            cd {current_path}/results/00-prepare/assemblies/{wildcards.sample}
            python {current_path}/workflow/scripts/overlapper.py -f {input.pair1} -r {input.pair2} --mo {params.minoverlap} --ms {params.minsim} > {log} 2>&1
            mv overlapped.fastq {output.assembled}
            mv notAssembled-1.fastq {output.un_forward}
            mv notAssembled-2.fastq {output.un_reverse}
            for i in {current_path}/results/00-prepare/assemblies/{wildcards.sample}/*.assembled.fastq; do sed -i "s/ /_/g" $i; done
            """

rule run_prinseq:
    input:
        assembled = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.assembled.fastq")
    output:
        os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}.assembled.fasta")
    params:
        num_threads = config["num_threads"]
    log:
        os.path.join(current_path, "results", "00-prepare", "logs", "prinseq", "{sample}.log")
    benchmark:
        os.path.join(current_path, "results", "benchmark", "{sample}_prepare_prinseqpp.txt")
    container:
        "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_prinseqpp")
    shell:
        """
        prinseq++ \
            -fastq {input.assembled} \
            -out_format 1 \
            -threads {params.num_threads} \
            -out_good {current_path}/results/00-prepare/assemblies/{wildcards.sample}.assembled.fasta \
            -out_bad {current_path}/results/00-prepare/assemblies/{wildcards.sample}.assembled.bad.fasta \
            > {log} 2>&1
        """

rule run_relabel:
    input:
        assembled_fasta = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}.assembled.fasta")
    output:
        os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}_relabel_notSingleton.fasta")
    log:
        os.path.join(current_path, "results", "00-prepare", "logs", "qiimepipe", "{sample}.log")
    benchmark:
        os.path.join(current_path, "results", "benchmark", "{sample}_prepare_relabel.txt")
    singularity:
        "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_qiimepipe")
    shell:
        """
        cd {current_path}/results/00-prepare/assemblies/
        python3.6 /qiimepipe/relabelReads-v2.py {wildcards.sample}.assembled.fasta . \
        > {log} 2>&1
        mv {wildcards.sample}_relabel.fasta {wildcards.sample}_relabel_notSingleton.fasta
        """

rule concatenate_and_rename:
    input:
        expand(os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}_relabel_notSingleton.fasta"), sample=SAMPLES)
    output:
        os.path.join(current_path, "results", "00-prepare", config["outputprepare"] + ".fasta")
    params:
        outputname = config["outputprepare"]
    shell:
        """
        cd {current_path}/results/00-prepare/assemblies/
        cat *relabel_notSingleton.fasta > {params.outputname}.fasta
        mv {params.outputname}.fasta {current_path}/results/00-prepare/
        """

rule concatenate_singletons:
    input:
        assembled_fastq = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.assembled.fastq"),
        unassembled_forward = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.forward.fastq"),
        unassembled_reverse = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}.unassembled.reverse.fastq"),
        singleton_truncated = os.path.join(current_path, "results", "00-prepare", "prepare_output", "{sample}_good.singleton.truncated")
    output:
        os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}_withSingleton.fastq")
    shell:
        """
        cat {input.assembled_fastq} {input.unassembled_forward} {input.unassembled_reverse} {input.singleton_truncated} > {output}
        sed -i 's/ /_/g' {output}
        """

rule run_prinseq_singleton:
    input:
        assembled_singleton = os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}", "{sample}_withSingleton.fastq")
    output:
        os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}.assembled.withSingleton.fasta")
    params:
        num_threads = config["num_threads"]
    log:
        os.path.join(current_path, "results", "00-prepare", "logs", "prinseq_singleton", "{sample}.log")
    benchmark:
        os.path.join(current_path, "results", "benchmark", "{sample}_prepare_prinseqpp_singleton.txt")
    singularity:
        "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_prinseqpp")
    shell:
        """
        prinseq++ \
            -fastq {input.assembled_singleton} \
            -out_format 1 \
            -threads {params.num_threads} \
            -out_good {current_path}/results/00-prepare/assemblies/{wildcards.sample}.assembled.withSingleton.fasta \
            -out_bad {current_path}/results/00-prepare/assemblies/{wildcards.sample}.assembled.withSingleton.bad.fasta \
            > {log} 2>&1
        """

rule run_relabel_singleton:
    input:
        assembled_fasta_singleton = expand(os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}.assembled.withSingleton.fasta"), sample=SAMPLES)
    output:
        os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}_relabel_withSingleton.fasta")
    log:
        os.path.join(current_path, "results", "00-prepare", "logs", "qiimepipe_singleton", "{sample}.log")
    benchmark:
        os.path.join(current_path, "results", "benchmark", "{sample}_prepare_relabel_singleton.txt")
    singularity:
        "{}/{}.sif".format(config['sif_dir'].rstrip("/"), "pimba_qiimepipe")
    shell:
        """
        cd {current_path}/results/00-prepare/assemblies/
        python3.6 /qiimepipe/relabelReads-v2.py {wildcards.sample}.assembled.withSingleton.fasta . \
        > {log} 2>&1
        mv {wildcards.sample}_relabel.fasta {wildcards.sample}_relabel_withSingleton.fasta
        """

rule concatenate_and_rename_singletons:
    input:
        expand(os.path.join(current_path, "results", "00-prepare", "assemblies", "{sample}_relabel_withSingleton.fasta"), sample=SAMPLES)
    output:
        os.path.join(current_path, "results", "00-prepare", config["outputprepare"] + "_withSingleton.fasta")
    params:
        outputname = config["outputprepare"]
    shell:
        """
        cd {current_path}/results/00-prepare/assemblies/
        cat *_relabel_withSingleton.fasta > {params.outputname}_withSingleton.fasta
        mv {params.outputname}_withSingleton.fasta {current_path}/results/00-prepare/
        rm -r {current_path}/results/00-prepare/assemblies/
        cd {current_path}/results/00-prepare/
        tar -czf prepare_output.tar.gz prepare_output/ && rm -r prepare_output/
        """